1.
Python is an object-oriented, high-level programming language with dynamic semantics that is interpreted. Its high-level built-in data structures, paired with dynamic typing and dynamic binding, making it ideal for Rapid Application Development as well as as a scripting or glue language for connecting existing components. Python's concise, easy-to-learn syntax prioritizes readability, which lowers software maintenance costs. Modules and packages are supported by Python, which fosters program modularity and code reuse. The Python interpreter and its substantial standard library are free to download and distribute in source or binary form for all major platforms.
Python is popular among programmers because of the enhanced productivity it offers. The edit-test-debug cycle is extraordinarily rapid because there is no compilation step. Python scripts are simple to debug: a bug or improper input will never result in a segmentation fault. Instead, when the interpreter finds a mistake, it throws an exception. The interpreter prints a stack trace if the application fails to catch the exception. Inspection of local and global variables, execution of arbitrary expressions, setting breakpoints, stepping through the code one line at a time, and so on are all possible with a source level debugger. The debugger is written in Python, demonstrating Python's introspective capabilities. On the other hand, adding a few print statements to the source code is frequently the quickest method to debug a program: the fast edit-test-debug cycle makes this simple approach quite successful.
In 2021, Python is predicted to be one of the most widely used programming languages. Python is popular because it is easier to understand. Python may be used in a wide range of fields. Python is a dynamically typed language with a simple grammar. Python is an interpreted language, which means it evaluates code line by line, making it simple to spot problems. Python has more built-in functions, reducing the amount of code that needs to be written.

2.
Data types are an important notion in the Python programming language. In Python, each value has its own Python data type. The classification of information objects or the categorizing of data values into some type of data category are both examples of data types. It helps to understand the kind of operations that will be performed on a value.
Python supports a variety of data types. Each value in Python has a datatype. Because everything in Python programming is an object, data types are essentially classes, and variables are instances (objects) of these classes. Python supports a number of standard data types, each with its own storage technique.
A list of Python data types could look like this.
It's necessary to keep in mind that data type is a crucial concept in programming.
Variables can hold a wide range of information, and different types can perform different functions.
Python comes pre-installed with the following data types in these categories:
Set Types: frozenset, set (Sets are unordered.)
Mapping Type: dict (The mapping objects are used to map hash table values to arbitrary objects.)
Sequence Types: range, tuple, list
Binary Types: memoryview, bytearray, bytes
Boolean Type: bool
Numeric Types: complex, float, int
Text Type: str


3.
A function is a piece of code that is called from another piece of code and then executed. A function is a square of well-organized, reusable code that performs a single, connected task. Capacities provide greater application security and a high level of code reuse. When we need the same repeating steps in multiple portions of the program with various variable names, we employ it. We group the stages that repeat themselves into a function and call it as needed. The function will be able to process the data and return the result. The def keyword is used to define a function in Python, followed by the function name and a list of variable names/parameters enclosed in round parenthesis.
After processing, a function can return a value. In-built functions are already programmed in libraries/modules and can be imported by a programmer. max (), min (), and other functions can compute the maximum and minimum value of an inventory supplied as a parameter, for example. When we need a feature that isn't built in, we can create our own function. For example, if we want to convert temperature from Fahrenheit to Celsius, we can construct our own custom function that takes an argument and returns a result. Below is an example of a function that transforms a given amount of hours to minutes: def hours to Minutes (hours): 60 hours of return time

4.
Python is an interpreter, cooperative, and object-oriented programming language with a print statement. Python, according to the assertion, combines "amazing strength with very plain syntax," which should pique the interest of people who teach programming. The print () command prints a message to the screen or to a standard output device. The message can be a string or another object that will be converted to a string before being shown.
The print () function outputs the specified data to the standard yield gadget (screen) or the content stream record. That single piece of code has a print explanation that we use every day in our programming without even realizing its complexity. The print () articulation's purpose is to print the specified question to either the standard yield gadget or the content stream record.
objects: This means the question to be printed, * demonstrates that there can be more than one object.
sep: This means the division which would be between the diverse objects. By default, this esteem is ‘‘.
end: The esteem for this parameter is printed at last.
file: It ought to be a question with a write(str) strategy. In the event that this esteem isn't specified, it prints objects on the standard yield gadget, i.e., screen.
flush: The stream gets coercively flushed on the off chance that this esteem is Genuine. By default, this esteem is False.




Codes(Corrections).

""" use \' for print the ' in the string"""
single_string = 'It\'s a single quote string'
"""print string"""
print(single_string)
----------------------------------------------
n1 = 5
n2 = 7.5
print(n1 + n2)

nstr1 = "abc"
print(nstr1 + str(n1))
---------------------------------------------
tup1 = ['Tom', 78]
tup1[1] = 90
print(tup1)

Output:
--------
['Tom', 90]

PART 1 CODE
print("New York Knicks!")
New York Knicks!

input()
computer science
Out[2]:
'computer science'

a = 6
if a == 6:
    # 4 indented spaces to this block of code
    print("a equals 6")
a equals 6


myString = 'New York Knicks'
print(type(myString))
<class 'str'>

n = 10
print(type(n))
<class 'int'>

n_float = 7.5
print(type(n_float))
<class 'float'>
In [11]:
single_string = 'Its a single quote string'
print(single_string)
  File "<ipython-input-11-dbe7c6e4d27f>", line 1
    single_string = 'It's a single quote string'
                        ^
SyntaxError: invalid syntax
In [13]:
double_string = "It's a double quote string"
print(double_string)
It's a double quote string
In [14]:
n1 = 5
n2 = 7.5
print(n1+n2)
12.5
In [18]:
nstr1 = "abc"
print(nstr1 + n1)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-18-1d5cacb6336b> in <module>
      1 nstr1 = "abc"
----> 2 print(nstr1 + n1)

TypeError: can only concatenate str (not "int") to str
In [19]:
nstr2 = "def"
print(nstr1 + nstr2)
abcdef
In [23]:
n1, n2 = 10, 11
In [24]:
n1
Out[24]:
10
In [25]:
n2
Out[25]:
11
In [27]:
result = 3 + 4.0 / 2 * 5  # DMAS
print(result)
13.0
In [28]:
# module operator %
remainder = 17%10
print(remainder)
7
In [29]:
# x ^ n
x = 5
n = 4
print(x ** n)
625
In [31]:
nstr = "abc"
ans = nstr * 10
In [32]:
print(len(ans))
30
In [39]:
name = "Harshit"
print("%s is a data scientist!" %name)
Harshit is a data scientist!
In [40]:
name.upper()
Out[40]:
'HARSHIT'
In [41]:
name.lower()
Out[41]:
'harshit'
In [42]:
nstr = "it is a nice day today."
nstr.capitalize()
Out[42]:
'It is a nice day today.'
In [44]:
name.index('s')
Out[44]:
3
In [45]:
name[2:5]
Out[45]:
'rsh'
In [46]:
name[2:6:2]
Out[46]:
'rh'
In [47]:
alist = [3,4,5]
print(alist)
[3, 4, 5]
In [48]:
alist = ['harshit', 2, 5.5]
print(alist)
['harshit', 2, 5.5]
In [49]:
alist.append(10)
alist.append(15)
print(alist)
['harshit', 2, 5.5, 10, 15]
In [50]:
alist.pop()
print(alist)
['harshit', 2, 5.5, 10]
In [53]:
alist[3]
Out[53]:
10
In [54]:
alist[1:]
Out[54]:
[2, 5.5, 10]
In [55]:
alist.append([1,2,3])
print(alist)
['harshit', 2, 5.5, 10, [1, 2, 3]]
In [56]:
alist*2
Out[56]:
['harshit', 2, 5.5, 10, [1, 2, 3], 'harshit', 2, 5.5, 10, [1, 2, 3]]
In [57]:
alist + alist
Out[57]:
['harshit', 2, 5.5, 10, [1, 2, 3], 'harshit', 2, 5.5, 10, [1, 2, 3]]
